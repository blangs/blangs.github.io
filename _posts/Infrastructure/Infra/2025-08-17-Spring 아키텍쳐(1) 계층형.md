---
title:  "Spring 아키텍쳐(1) 계층형"
excerpt: "Spring 아키텍쳐(1) 계층형 입니다."

categories:
  - infra
tags:
  - [인프라, 아키텍처]

toc: true
toc_sticky: true

last_modified_at: 2025-08-17T15:30:00-15:30:00
---


## 개요
### 계층형 특징
> ❗<span style='color:green'>***규모가 작고, 도메인이 적은 경우 적합***</span>  
> 💡 *<span style='color:blue'>**계층형 패키지 안에 클래스들이 구분이 안될만큼 많아질 경우가 적다.**</span>  
> 💡 *<span style='color:blue'>**애플리케이션 흐름 및 가독성이 상대적으로 좋다.**</span>  
> 💡 *<span style='color:blue'>**행위별로 클래스를 분리하는 경우가 적다.**</span>  
> 💡 *<span style='color:blue'>**도메인 변경이 일어나도 규모가 작고 도메인이 적은만큼 변경범위가 적다.**</span>  
  
### 도메인형 특징
> ❗<span style='color:green'>***구조규모가 크고, 도메인이 많은 경우 적합***</span>  
> 💡 *<span style='color:blue'>**규모가 크고, 도메인이 많은 만큼 도메인의 응집도가 높은 것이 중요할 것이다.**</span>  
> 💡 *<span style='color:blue'>**규모가 큰 만큼 행위별로 클래스를 분리하는 경우가 존재하기 때문**</span>  



## 전통적인 계층형 Mybatis <> JPA 비교 (작성중)
```bash
#작성중
```



## 1. 전통적 MyBatis 구조 [2000년대 ~ 2010년대 초반]  ── "고전 정석형"
: MyBatis의 고전적 정석 (2000년대 ~ 2010년대 초반) Spring + MyBatis 실무에서 “관례적으로” 사용하던 완전 전통 구조.  
  
![hierarchical1](/assets/images/Infrastructure/Infra/architecture-hierarchical1.png)
  
```bash
# 초창기: DAO + VO + mapper.xml (정통형)
project-root/
├── controller
│   └── UserController.java
├── service
│   └── UserService.java 
│
├── dao                  # 이 전통방식은 네임스페이스+"."+SQL ID 로 지정해야했었다.
│   └── UserDao.java     # 일반적으로 DAO 는 데이터베이스의 테이블과 일치한다. 즉, 테이블 중심이라고 할 수 있다.
|                        #   -> 구체적인 데이터 접근 로직이 DAO에 노출됨
│
├── vo                   # 전통 구조에서는 DB 매핑용 객체를 VO(Value Object) 라고 불렀음.
│   └── UserVo.java      #   -> (VO는 DB 매핑용 데이터 객체)
│
└── resources
    └── mapper
        └── user-mapper.xml

# → Controller → Service → DAO → mapper.xml
# → DB 객체: VO (Value Object)
# → 특징: DAO 직접 SqlSession 호출

```

### DAO 패턴
> ❗<span style='color:green'>***DAO 방식 (SQL 쿼리/DB 접근이 노출됨)***</span>  
>   
> ```java
> public class UserDao {
>    //DAO가 직접 SqlSession을 열고 SQL 매퍼의 네임스페이스와 쿼리 ID를 지정해 호출
>    private SqlSessionFactory sqlSessionFactory; 
>
>    public UserDao(SqlSessionFactory sqlSessionFactory) {
>        this.sqlSessionFactory = sqlSessionFactory;
>    }
>
>    public UserDto findUserById(Long id) {
>        try (SqlSession session = sqlSessionFactory.openSession()) {
>            // 직접 매퍼를 호출하고 SQL 실행 
>            return session.selectOne("com.example.mapper.UserMapper.selectUserById", id);
>        }
>    }
>
>    public void insertUser(UserDto user) {
>        try (SqlSession session = sqlSessionFactory.openSession()) {
>            session.insert("com.example.mapper.UserMapper.insertUser", user);
>            session.commit();
>        }
>    }
> 
>    // 추가적인 CRUD 메서드도 직접 구현
> }
>  
> ```
>  
> 💡 * <span style='color:red'>**SQL과 DB접근 코드가 모두 DAO 내부에 있음 (DAO: SQL과 DB 접근 코드가 직접 구현체에 노출)**</span>  
> 💡 * <span style='color:red'>**SQ호출하는 측에서는 SQL 쿼리나 DB 연결을 전혀 모르고 사용불가**</span>  
> 💡 * <span style='color:red'>**그러나 구체적인 데이터 접근 로직이 DAO에 노출됨**</span>  
>   
> ❗<span style='color:green'>***일반적으로 DAO 는 데이터베이스의 테이블과 일치한다. 즉, 테이블 중심이라고 할 수 있다.***</span>  
> 💡 * <span style='color:red'>**DAO 는 영속성 벤더들의 API 와 비즈니스 로직 그 중간에 위치하여 서로를 연결해주는 테이블중심의 어댑터와 같은 역할이다.**</span>  
> 💡 * <span style='color:red'>**DAO(Data Access Object) 패턴은 이름 그대로 데이터에 접근하기 위한 객체이다. 그 자체가 영속성의 추상화이기 떄문에, 애플리케이션(도메인) 계층이 아닌, 영속성 계층에 속한다. 이 떄문에 DAO 가 도메인 패키지에 위치하면 어색한 느낌을 준다. (뭔가 캡슐화한 로직을 구현한것이 아니다. 어댑터다.)**</span>  
> 💡 * <span style='color:red'>**애플리케이션 계층에선 벤더의 API 구현체를 직접 사용하지 않는 대신에 DAO 객체를 이용한다. 이로 인해 데이터 소스가 변경되더라도 비즈니스 로직을 해치지 않는, 변화를 없도록 하는 강한 결합 문제를 해결했다. 또한 각 벤더별 구현의 차이점을 극복했다.**</span>  
  
  

## 2. [2010년대 중반]  ── "Spring 스타일 흡수"
: 전통적인 MyBatis DAO/VO 구조는 2010년대 초반까지는 거의 업계 표준처럼 쓰였는데, 그 이후에는 점차 다른 형태들이 등장하기 시작한다.  
  
![hierarchical2](/assets/images/Infrastructure/Infra/architecture-hierarchical2.png)
  
```bash
# Repository, DTO/Entity 등장 (JPA 용어 흡수)	
project-root/
├── controller
│   └── UserController.java
├── service                     
│   └── UserService.java 
│
├── repository                  # JPA(특히 Spring Data JPA)에서 Repository 패턴을 쓰는 게 유행하기 시작. (초반기..)
│   └── UserRepository.java     #   -> MyBatis도 Repository 네이밍으로 맞춤. ( UserDao.java ==> UserRepository.java )
|                               #
|								# [Mapper Interface 직접 사용 (DAO 제거)] 
|								#   -> MyBatis가 Mapper 인터페이스를 프록시로 자동 구현해주기 때문에 DAO 계층이 불필요해짐.
|                               #      즉, MyBatis에서 @Mapper 인터페이스를 지원하면서 DAO 구현체를 생략할 수 있게 됨.
│								#   -> 패키지 이름+"."+인터페이스이름+"."+메서드이름이 네임스페이스+"."+SQL의 ID를 설정하면 자동 주입
|
├── dto/entity                          # [VO → DTO/Entity 용어 변경] 
│   └── UserDto.java / UserEntity.java  #   -> 이후 JPA 영향으로 VO 대신 Entity, DTO 라는 용어가 보편화.
|										#   -> 특히 "Entity = DB 매핑, DTO = 데이터 전달" 이라는 식으로 역할 구분을 따지기 시작.
│                       
|
│
└── resources
    └── mapper
        └── user-mapper.xml

# → Controller → Service → Repository → mapper.xml
# → DB 객체: DTO, Entity 용어로 전환
# → 특징: JPA 관례(Repository, Entity) 영향

```
  
  
### 레파지토리 패턴 
![사진1](/assets/images/Infrastructure/Infra/repository-pattern1.png)
![사진2](/assets/images/Infrastructure/Infra/repository-pattern2.png)
![사진3](/assets/images/Infrastructure/Infra/repository-pattern3.png)
![사진4](/assets/images/Infrastructure/Infra/repository-pattern4.png)

> ❗<span style='color:green'>***Repository 방식 (구현 숨기고 메서드 호출만 노출, 객체지향적)***</span>  
> 💡 * <span style='color:red'>**SQL 쿼리 작성, DB 세부 연결, ResultSet 처리 등은 모두 프레임워크가 대신 처리**</span>  
> 💡 * <span style='color:red'>**개발자는 userRepository.findById(id)라는 간단한 객체 지향 메서드 호출만 하면 됨 (Repository: SQL, DB 동작이 프레임워크 뒤에 숨겨져, 메서드 호출만으로 데이터 조작 가능)**</span>  
> 💡 * <span style='color:red'>**비즈니스 로직에 집중 가능**</span>  
>   
> ❗<span style='color:green'>***Repository 는 영구 저장소를 의미하는 것이 아닌, 객체의 상태를 관리하고 저장하는 단순한 저장소***</span>  
> 💡 * <span style='color:red'>**DAO패턴과 다르게 Repository 는 단순히 객체의 상태(State) 를 관리하는 저장소다.**</span>  
> 💡 * <span style='color:red'>**Repository 는 단순히 객체의 Collection 을 저장하고, 검색하는등의 동작을 캡슐화한 개념이라고 할 수 있다.**</span>  
> 💡 * <span style='color:red'>**도메인 정보를 가지고 있어야하는 Repository 는 DAO 와 같이 영속성 계층이 아닌, 도메인 계층으로 분류하는 것이 올바르다.**</span>  
>    
> 즉, DAO 는 영속성 계층에서 직접적으로 데이터베이스 벤더 API, 테이블에 접근하는 개념이지만, Repository 는 도메인 객체의 상태를 관리 및 저장하는 개념에 가깝다는 점에서 차이를 보인다.  
> 결국, Repository 는 객체의 정보를 가진 저장소에 대한 관리 에 대한 책임을 위임받은 인터페이스이다. 이 떄문에 저장소는 인메모리에 위치할 수도 있고, 애플리케이션 외부의 어떤 단순한 파일이 될 수도 있고, MySQL 과 같은 RDBMS 가 될 수도 있다. 객체의 상태를 어떤, 어디의 저장소에 저장하는것이 중요한 것이 아니라, 그냥 어떤 자장소에 데이터를 넣고, 읽어오고, 삭제하는 기능을 충실히 제공해주는 것이 Repository 의 역할이다.  
> {: .notice--info}  
   
  
   
## 3. [2010년대 중반 ~ 후반]  ── "Mapper Interface 직결형"
  
![hierarchical3](/assets/images/Infrastructure/Infra/architecture-hierarchical3.png)
  
```bash
# Mapper interface 직접 사용, DAO 제거
project-root/
├── controller
│   └── UserController.java
├── service                     
│   └── UserService.java 
│
├── mapper                           # JPA(특히 Spring Data JPA)에서 Repository 패턴을 쓰는 게 유행하기 시작. 
│   └── UserMapper.java (@Mapper)    #   -> MyBatis도 Repository 네이밍으로 맞춤. ( UserDao.java ==> UserRepository.java )
|								     # [Mapper Interface 직접 사용 (DAO 제거)] 
|								#   -> MyBatis가 Mapper 인터페이스를 프록시로 자동 구현해주기 때문에 DAO 계층이 불필요해짐.
|                               #      즉, MyBatis에서 @Mapper 인터페이스를 지원하면서 DAO 구현체를 생략할 수 있게 됨.
│								#   -> 패키지 이름+"."+인터페이스이름+"."+메서드이름이 네임스페이스+"."+SQL의 ID를 설정하면 자동 주입
|
├── dto/entity                          # [VO → DTO/Entity 용어 변경] 
│   └── UserDto.java / UserEntity.java  #   -> 이후 JPA 영향으로 VO 대신 Entity, DTO 라는 용어가 보편화.
|										#   -> 특히 "Entity = DB 매핑, DTO = 데이터 전달" 이라는 식으로 역할 구분을 따지기 시작.
│                       
|
│
└── resources
    └── mapper
        └── user-mapper.xml

# → Controller → Service → Mapper(interface) → mapper.xml
# → 특징: DAO 구현체 불필요(JPA인경우는 SQL마저 ORM 자동 생성하여 불필요)
#        , Repository는 인터페이스만 선언, 구현체 자동 제공 (MyBatis가 Mapper 인터페이스 프록시 자동 생성)
#        , Entity = DB 매핑, DTO = 데이터 전달

```





### MyBatis 전통 계층형
```bash
#1 [컨트롤러 > 서비스 > DAO > 매퍼 > mapper.xml] 방식
Controller → Service(interface) → Service(Impl) → Repository(interface) → RepositoryImpl → mapper.xml → DB
Controller → Service(Impl) → Repository(interface) → RepositoryImpl → mapper.xml → DB

#2 [컨트롤러 > 서비스 > DAO > 매퍼 > mapper.xml] 방식
Controller → Service(Impl) → Repository(interface) → RepositoryImpl → mapper.xml → DB

Controller
  ↓
Service
  ↓
Repository
  ↓
Mapper(interface)
  ↓
mapper.xml

```


- Controller -> Service -> Repository -> mapper.xml
- Controller -> Service -> Repository -> Mapper -> mapper.xml
- Controller -> Service -> Mapper -> mapper.xml










1-1. 계층형 구조 장단점  
장점  
1. 프로젝트 전반적인 이해도가 낮아도, 패키지 구조만 보고 전체적인 구조를 파악할 수 있다.  
애플리케이션의 API를 보고 흐름을 파악하고 싶다면, Controller 패키지 하나만 보고 파악할 수 있다.  
애플리케이션의 비즈니스 로직을 보고 싶다면, Service 패키지 하나만 보고 파악할 수 있다.  
2. 계층별 응집도가 높아진다.   
계층별 수정이 일어날 때, 하나의 패키지만 보면 된다.  
    

단점  
1. 도메인별 응집도가 낮다. (패키지로 애플리케이션의 기능을 구분짓지 못한다)  
1-1. 도메인의 흐름을 파악하기 힘들다.  
Product 도메인의 흐름을 보고 싶을 때, 모든 계층 패키지를 봐야한다.  
하나의 패키지안에 여러 도메인(상품, 장바구니, 사용자)들이 섞여 있다.  
1-2. 도메인과 관련된 스펙 & 기능이 변경되었을 때, 변경 범위가 크다.  
Product에 대한 변경점이 있을 때, 여러 패키지에서 변경이 일어난다.   
2. 유스케이스(사용자의 행위) 표현이 어렵다.  
규모가 커지면, 유스케이스별로 클래스를 분리할 때가 있다.  
ex : 상품 등록 유스 케이스 -> RegisterProductService  
하지만, 계층형에서는 계층으로 패키지가 묶이기 때문에 위와 같이 네이밍해서 분리하기 어렵다.  
3. 규모가 커지면 하나의 패키지 안에 여러 클래스들이 모여서 구분이 어려워진다.   


### 도메인형
```bash
product
	⎿ controller
	⎿ service
	⎿ dao
	⎿ dto

member
	⎿ controller
	⎿ service
	⎿ dao
	⎿ dto
    
cart
	⎿ controller
	⎿ service
	⎿ dao
	⎿ dto

```

```bash
ㄴsrc/main/java/com/example/demo
	ㄴ DemoApplication.java
    ㄴ domain
    	ㄴ user
          ㄴ controller
          ㄴ service
          ㄴ repository
          ㄴ domain
        ㄴ post
          ㄴ controller
          ㄴ service
          ㄴ repository
          ㄴ domain
    ㄴ global
    	ㄴ auth
        ㄴ common
        ㄴ config

# domain
# domain을 담당하는 directory

# global 
# 프로젝트 전방위적으로 사용되는 객체들로 구성된다.
# config : 스프링 각종 설정
# common : 공통으로 사용되는 Value 객체들
# auth : 인증/인가에 사용되는 설정

```

2-1. 도메인형 구조 장단점  
장점  
1. 도메인별 응집도가 높아진다.   
1-1. 도메인의 흐름을 파악하기 쉽다.  
Product 도메인의 흐름을 보고 싶을 때, Product 패키지 하나만 보면 된다.  
1-2. 도메인과 관련된 스펙 & 기능이 변경되었을 때, 변경 범위가 적다.  
Product에 대한 변경점이 있을 때, Product 패키지만 변경이 일어난다.  
2. 유스케이스별로 세분화해서 표현이 가능하다.  
ex : 상품 등록 유스 케이스 -> RegisterProductService  
ex : 상품 검색 유스 케이스 -> SearchProductService  
도메인별로 패키지가 나뉘기 때문에 product 패키지에서 위와 같은 네이밍으로 분리할 수 있다.  

단점  
애플리케이션의 전반적인 흐름을 한눈에 파악하기가 어렵다.  
흐름을 파악하기 위해 여러 패키지를 왔다갔다 해야할 가능성이 높다.  
개발자의 관점에 따라 어느 패키지에 둘지 애매한 클래스들이 존재한다.  
Welcome 페이지를 맵핑하는 컨트롤러일 때, 어느 도메인 패키지에 위치할지 개발자에 따라 다를 수 있다.  
자신이 예상하는 패키지와 다를 때, 해당 클래스를 찾기가 어렵다.  

## 선택
🎯 3. 결론 - 계층형 VS 도메인형 어느 구조를 선택할까?  
위에서 계층형과 도메인형 패키지 구조와 장단점을 살펴봤다.  

그렇다면, 어떤 패키지 구조를 선택해야할까?  

장단점을 비교해보면서 '무조건적으로 좋은 것, 정답은 없다'라고 느꼈다!  

프로젝트 및 애플리케이션 규모 및 상황에 따라 장단점을 비교해서 선택하는 것이 좋을 것 같다고 생각했다.  

그렇다면, 어떤 기준으로 선택을 할까?  

일단 프로젝트 경험이 많이 없는 지금 내가 정한 기준은 다음과 같다.  

(아직 프로젝트 경험이 많이 없어서 추후에 경험해보면서 기준이 바뀔 수도 있을 것 같다!)  

