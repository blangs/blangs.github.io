---
title:  "Spring 아키텍쳐(1) 계층형"
excerpt: "Spring 아키텍쳐(1) 계층형 입니다."

categories:
  - infra
tags:
  - [인프라, 아키텍처]

toc: true
toc_sticky: true

last_modified_at: 2025-08-17T15:30:00-15:30:00
---


## 개요
### 계층형 특징
> ❗<span style='color:green'>***규모가 작고, 도메인이 적은 경우 적합***</span>  
> 💡 *<span style='color:blue'>**계층형 패키지 안에 클래스들이 구분이 안될만큼 많아질 경우가 적다.**</span>  
> 💡 *<span style='color:blue'>**애플리케이션 흐름 및 가독성이 상대적으로 좋다.**</span>  
> 💡 *<span style='color:blue'>**행위별로 클래스를 분리하는 경우가 적다.**</span>  
> 💡 *<span style='color:blue'>**도메인 변경이 일어나도 규모가 작고 도메인이 적은만큼 변경범위가 적다.**</span>  
  
### 도메인형 특징
> ❗<span style='color:green'>***구조규모가 크고, 도메인이 많은 경우 적합***</span>  
> 💡 *<span style='color:blue'>**규모가 크고, 도메인이 많은 만큼 도메인의 응집도가 높은 것이 중요할 것이다.**</span>  
> 💡 *<span style='color:blue'>**규모가 큰 만큼 행위별로 클래스를 분리하는 경우가 존재하기 때문**</span>  



## 전통적인 계층형 Mybatis <> JPA 비교 (작성중)
```bash
#작성중
```



## 1. [2000년대 ~ 2010년대 초반]  ── "고전 정석형"
: MyBatis의 고전적 정석 (2000년대 ~ 2010년대 초반) Spring + MyBatis 실무에서 “관례적으로” 사용하던 완전 전통 구조.  
  
![hierarchical1](/assets/images/Infrastructure/Infra/architecture-hierarchical1.png)
  
```bash
# 초창기: DAO + VO + mapper.xml (정통형)
project-root/
├── controller
│   └── UserController.java
├── service
│   └── UserService.java 
│
├── dao                  # 이 전통방식은 네임스페이스+"."+SQL ID 로 지정해야했었다.
│   └── UserDao.java     # 일반적으로 DAO 는 데이터베이스의 테이블과 일치한다. 즉, 테이블 중심이라고 할 수 있다.
|                        #   -> 구체적인 데이터 접근 로직이 DAO에 노출됨
│
├── vo                   # 전통 구조에서는 DB 매핑용 객체를 VO(Value Object) 라고 불렀음.
│   └── UserVo.java      #   -> (VO는 DB 매핑용 데이터 객체)
│
└── resources
    └── mapper
        └── user-mapper.xml

# → Controller → Service → DAO → mapper.xml
# → DB 객체: VO (Value Object)
# → 특징: DAO 직접 SqlSession 호출

```

### DAO 패턴
> ❗<span style='color:green'>***DAO 방식 (SQL 쿼리/DB 접근이 노출됨)***</span>  
>   
> ```java
> public class UserDao {
>    //DAO가 직접 SqlSession을 열고 SQL 매퍼의 네임스페이스와 쿼리 ID를 지정해 호출
>    private SqlSessionFactory sqlSessionFactory; 
>
>    public UserDao(SqlSessionFactory sqlSessionFactory) {
>        this.sqlSessionFactory = sqlSessionFactory;
>    }
>
>    public UserDto findUserById(Long id) {
>        try (SqlSession session = sqlSessionFactory.openSession()) {
>            // 직접 매퍼를 호출하고 SQL 실행 
>            return session.selectOne("com.example.mapper.UserMapper.selectUserById", id);
>        }
>    }
>
>    public void insertUser(UserDto user) {
>        try (SqlSession session = sqlSessionFactory.openSession()) {
>            session.insert("com.example.mapper.UserMapper.insertUser", user);
>            session.commit();
>        }
>    }
> 
>    // 추가적인 CRUD 메서드도 직접 구현
> }
>  
> ```
>  
> 💡 * <span style='color:red'>**SQL과 DB접근 코드가 모두 DAO 내부에 있음 (DAO: SQL과 DB 접근 코드가 직접 구현체에 노출)**</span>  
> 💡 * <span style='color:red'>**SQ호출하는 측에서는 SQL 쿼리나 DB 연결을 전혀 모르고 사용불가**</span>  
> 💡 * <span style='color:red'>**그러나 구체적인 데이터 접근 로직이 DAO에 노출됨**</span>  
>   
> ❗<span style='color:green'>***일반적으로 DAO 는 데이터베이스의 테이블과 일치한다. 즉, 테이블 중심이라고 할 수 있다.***</span>  
> 💡 * <span style='color:red'>**DAO 는 영속성 벤더들의 API 와 비즈니스 로직 그 중간에 위치하여 서로를 연결해주는 테이블중심의 어댑터와 같은 역할이다.**</span>  
> 💡 * <span style='color:red'>**DAO(Data Access Object) 패턴은 이름 그대로 데이터에 접근하기 위한 객체이다. 그 자체가 영속성의 추상화이기 떄문에, 애플리케이션(도메인) 계층이 아닌, 영속성 계층에 속한다. 이 떄문에 DAO 가 도메인 패키지에 위치하면 어색한 느낌을 준다. (뭔가 캡슐화한 로직을 구현한것이 아니다. 어댑터다.)**</span>  
> 💡 * <span style='color:red'>**애플리케이션 계층에선 벤더의 API 구현체를 직접 사용하지 않는 대신에 DAO 객체를 이용한다. 이로 인해 데이터 소스가 변경되더라도 비즈니스 로직을 해치지 않는, 변화를 없도록 하는 강한 결합 문제를 해결했다. 또한 각 벤더별 구현의 차이점을 극복했다.**</span>  
  
  

## 2. [2010년대 중반]  ── "Spring 스타일 흡수"
: 전통적인 MyBatis DAO/VO 구조는 2010년대 초반까지는 거의 업계 표준처럼 쓰였는데, 그 이후에는 점차 다른 형태들이 등장하기 시작한다.  
  
![hierarchical2](/assets/images/Infrastructure/Infra/architecture-hierarchical2.png)
  
```bash
# Repository, DTO/Entity 등장 (JPA 용어 흡수)	
project-root/
├── controller
│   └── UserController.java
├── service                     
│   └── UserService.java 
│
├── repository                  # JPA(특히 Spring Data JPA)에서 Repository 패턴을 쓰는 게 유행하기 시작. (초반기..)
│   └── UserRepository.java     #   -> MyBatis도 Repository 네이밍으로 맞춤. ( UserDao.java ==> UserRepository.java )
|                               #
|								# [Mapper Interface 직접 사용 (DAO 제거)] 
|								#   -> MyBatis가 Mapper 인터페이스를 프록시로 자동 구현해주기 때문에 DAO 계층이 불필요해짐.
|                               #      즉, MyBatis에서 @Mapper 인터페이스를 지원하면서 DAO 구현체를 생략할 수 있게 됨.
│								#   -> 패키지 이름+"."+인터페이스이름+"."+메서드이름이 네임스페이스+"."+SQL의 ID를 설정하면 자동 주입
|
├── dto/entity                          # [VO → DTO/Entity 용어 변경] 
│   └── UserDto.java / UserEntity.java  #   -> 이후 JPA 영향으로 VO 대신 Entity, DTO 라는 용어가 보편화.
|										#   -> 특히 "Entity = DB 매핑, DTO = 데이터 전달" 이라는 식으로 역할 구분을 따지기 시작.
│                       
|
│
└── resources
    └── mapper
        └── user-mapper.xml

# → Controller → Service → Repository → mapper.xml
# → DB 객체: DTO, Entity 용어로 전환
# → 특징: JPA 관례(Repository, Entity) 영향

```
  
  
### 레파지토리 패턴 
![사진1](/assets/images/Infrastructure/Infra/repository-pattern1.png)
![사진2](/assets/images/Infrastructure/Infra/repository-pattern2.png)
![사진3](/assets/images/Infrastructure/Infra/repository-pattern3.png)
![사진4](/assets/images/Infrastructure/Infra/repository-pattern4.png)

> ❗<span style='color:green'>***Repository 방식 (구현 숨기고 메서드 호출만 노출, 객체지향적)***</span>  
> 💡 * <span style='color:red'>**SQL 쿼리 작성, DB 세부 연결, ResultSet 처리 등은 모두 프레임워크가 대신 처리**</span>  
> 💡 * <span style='color:red'>**개발자는 userRepository.findById(id)라는 간단한 객체 지향 메서드 호출만 하면 됨 (Repository: SQL, DB 동작이 프레임워크 뒤에 숨겨져, 메서드 호출만으로 데이터 조작 가능)**</span>  
> 💡 * <span style='color:red'>**비즈니스 로직에 집중 가능**</span>  
>   
> ❗<span style='color:green'>***Repository 는 영구 저장소를 의미하는 것이 아닌, 객체의 상태를 관리하고 저장하는 단순한 저장소***</span>  
> 💡 * <span style='color:red'>**DAO패턴과 다르게 Repository 는 단순히 객체의 상태(State) 를 관리하는 저장소다.**</span>  
> 💡 * <span style='color:red'>**Repository 는 단순히 객체의 Collection 을 저장하고, 검색하는등의 동작을 캡슐화한 개념이라고 할 수 있다.**</span>  
> 💡 * <span style='color:red'>**도메인 정보를 가지고 있어야하는 Repository 는 DAO 와 같이 영속성 계층이 아닌, 도메인 계층으로 분류하는 것이 올바르다.**</span>  
>    
> 즉, DAO 는 영속성 계층에서 직접적으로 데이터베이스 벤더 API, 테이블에 접근하는 개념이지만, Repository 는 도메인 객체의 상태를 관리 및 저장하는 개념에 가깝다는 점에서 차이를 보인다.  
> 결국, Repository 는 객체의 정보를 가진 저장소에 대한 관리 에 대한 책임을 위임받은 인터페이스이다. 이 떄문에 저장소는 인메모리에 위치할 수도 있고, 애플리케이션 외부의 어떤 단순한 파일이 될 수도 있고, MySQL 과 같은 RDBMS 가 될 수도 있다. 객체의 상태를 어떤, 어디의 저장소에 저장하는것이 중요한 것이 아니라, 그냥 어떤 자장소에 데이터를 넣고, 읽어오고, 삭제하는 기능을 충실히 제공해주는 것이 Repository 의 역할이다.  
> {: .notice--info}  
   
  
   
## 3. [2010년대 중반 ~ 후반]  ── "Mapper Interface 직결형"
  
![hierarchical3](/assets/images/Infrastructure/Infra/architecture-hierarchical3.png)
  
```bash
# Mapper interface 직접 사용, DAO 제거
project-root/
├── controller
│   └── UserController.java
├── service                     
│   └── UserService.java 
│
├── mapper                           # JPA(특히 Spring Data JPA)에서 Repository 패턴을 쓰는 게 유행하기 시작. 
│   └── UserMapper.java (@Mapper)    #   -> MyBatis도 Repository 네이밍으로 맞춤. ( UserDao.java ==> UserRepository.java )
|								     # [Mapper Interface 직접 사용 (DAO 제거)] 
|								#   -> MyBatis가 Mapper 인터페이스를 프록시로 자동 구현해주기 때문에 DAO 계층이 불필요해짐.
|                               #      즉, MyBatis에서 @Mapper 인터페이스를 지원하면서 DAO 구현체를 생략할 수 있게 됨.
│								#   -> 패키지 이름+"."+인터페이스이름+"."+메서드이름이 네임스페이스+"."+SQL의 ID를 설정하면 자동 주입
|
├── dto/entity                          # [VO → DTO/Entity 용어 변경] 
│   └── UserDto.java / UserEntity.java  #   -> 이후 JPA 영향으로 VO 대신 Entity, DTO 라는 용어가 보편화.
|										#   -> 특히 "Entity = DB 매핑, DTO = 데이터 전달" 이라는 식으로 역할 구분을 따지기 시작.
│                       
|
│
└── resources
    └── mapper
        └── user-mapper.xml

# → Controller → Service → Mapper(interface) → mapper.xml
# → 특징: DAO 구현체 불필요(JPA인경우는 SQL마저 ORM 자동 생성하여 불필요)
#        , Repository는 인터페이스만 선언, 구현체 자동 제공 (MyBatis가 Mapper 인터페이스 프록시 자동 생성)
#        , Entity = DB 매핑, DTO = 데이터 전달

```




## 참고
: 인터페이스와 구현체 분리는 하면 좋다. 길어질 뿐이지.. 프로젝트 몸집별로 정하도록 하자.